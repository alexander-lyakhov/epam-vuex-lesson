
Сейчас я предлагаю рассмотреть, как теория работает в реальных условиях.
Специально для этого урока я приготовил небольшой пример, который поможет нам проследить все оснавные принципы работы со стором.
Мы рассмотрим такие вопросы, как доступ к данным в стейте, работа с геттерами, мутации и экшины. А также рассмотрим разделение стора на отдельные модули.
Применение модулей является очень удобной практикой в больших приложениях.

Для начала я покажу приложение в работе, а затем последовательно, шаг за шагом мы реализуем лигику этого приложения при помощи Vuex.

***
Переключаемся на приложение
***

Вначале пара слов о приложении.
Основное назначение этого примера - управление списком пользователей. Данные о пользователях как раз хранятся в сторе.

Что у нас тут есть? В двух словах расскажу об элементах управления и опишу с какими функциями Vuex'а эти элементы связаны.

- Немного информации об аккаунте. Эта информация тоже хранится в сторе и мы будем читать ее напрямую из стейта.

- Счетчик пользователей. Его мы реализуем при помощи геттеров внутри стора. Напомню, что компоненты Vue тоже могут использовать внутри себя геттеры
  и в этом примере мы также будем ими польваться.

- Поле для ввода имени нового пользователя. С его помощью будем добавлять новые данные в стор.

- После добавления, мы имеем возможность удалить записи из стора. Обе эти операции (добавление и удаление) изменяют данные в стейте, и для этой цели служат мутации.

- А таже у нас есть возможность подгружать данные с удаленного сервера.
  Это асинхронная операция и специально для таких таких операций (для работы с асинхронными действиями) предназначены экшены.
  Напомню, что в отличии от экшинов МУТАЦИИ являются операциями синхронными.


Ссылку на этот пример я оставлю в конце лекции.



*  *  *

Теперь после того, как мы определились, какое поведение мы ожидаем от нашего приложения, я предлагаю перейти к его реализации.
У меня есть копия этого приложения без стора. Соответственно у нас нет ни каких данных и логики по работе с этими данными.

Мы можем видеть вместо имени в аккаунте строку Name, которая вписана туда хардкодом. Вместо аватарки мы вообще ни чего не видим.
Значение счетка тоже установлено в 0. Сейчас мы будем это исправлять.

Прежде всего давайте создадим и зарегистрируем наше хранилище. Для этого в папке src создадим новую папку store и в ней файл с однойменным названием.
Теперь осталось создать сам стор )
В качестве аргумента конструктор стора принимает объект с конфигурацией. Сейчас этот объект пустой. Конфигурация представляет собой набор вложенных подобъектов,
которые внутри себя содержат данные, а так же методы взыимодействия с с этими данными. Не пугайтесь, сейчас все увидите сами )
Главной и единственной обязательной частью стора является state, в котором собственно данне и хранятся. Те из вас, кто работал с redux'ом смогут заметить сходство в терминалогии.
Суть у них тоже одна.
Итак давайте опишим стейт.

Наш стор готов. Но пока он существует сам по себе, приложение о ним ни чего не знает. Следующее, что нам нужно сделать - это импортировать наш стор в main.js
Затем нам нужно передать импортированный стор в конйигурацию корневого компонента.
Это нужно для того, чтобы любой дочерний компонент внутри себя имел доступ к стору без необходимости импортировать его.
Ну а поскольку любой компонент в приложении является дочерним по отношению к корневому, то выходит, что все компоненты автоматически получают доступ к стору.

Итак стор создан и подключен. Можно переходить к работе с данными из стора. Давайте попробуем вывести поле accountName в хедер. Будем желать это в файле nav-bar.vue
Для начала рассмотрим, какие есть способы обратиться к данным в сторе из компонента. Давайте создадим хук created в котором выведем в консоль поле accountName из стора.

		created() {
			console.log(this.$store.state.accountName)
		}

Как вы можете видеть в консоль вывелось значение поля, взятого из стейта. Теоретически мы можем указать в шаблоне прямо это выражение для вывода имени.
Это работает, но согласитесь это не очень красивая запись. Обычно так не делают, потому что есть возможность сделать это красивее и понятнее.
Мы можем создать вычисляемое поле, которое так и назовем accountName, и оно будет нам возвращать значение этого выражения.

		computed: {
			accountName() {
				return this.$store.state.accountName;
			}
		}

Теперь нам достаточно указать в шаблоне только имя вычисляемого свойства.
То же самое проделаем для аватара.

			accountAvatar() {
				return this.$store.state.accountAvatar;
			}

Как видите, такой способ более изящный и не перегружает шаблон.
Существует еще один способ обратиться к стору - через маппинг стейта и методов. Он немного напоминает способ, который применяется в связке рекат-редакс.
Давайте посмотрим, как это происходит.

Прежде всего нам нужно импортировать метод mapState из Vuex.
Затем в секции computed мы вызываем этот метод, которому в качестве параметра передаем массив со списком свойств, котороые мы хотим получить из стейта.

		computed: {
			...mapState(['accountName', 'accountAvatar']),
		}

Метод mapState возвращает объект, который мы разворачиваем при помощи spread-оператора и подмешиваем его к объкту computed.
Внутри computed по прежнему могут находиться вычисляемые свойства, которые нам необходимы.
Такой способ получения данных из стора еще проще, чем способы рассмотренные ранее.
Кроме того он удобней, когда нам нужно запросить большое количиство полей из стейта. В этом случае нам не придется для каждого свойства определять геттеры.
Стоит отметить, что метод mapState может принимать не только массив, но и объект с парами ключ-значение. Давайте я покажу такоу форму записи.

		...mapState({
			accountName: 'accountName',
			accountAvatar: 'accountAvatar'
		})

Такой формат можно применять, если мы хотим изменить название свойства, использовать это свойство в компоненте под другим именем.
Тогда мы просто указываем имя ключа, которое нам нужно, а имя свойства в стейте указываем таким, каким оно там определено.
Однако такая форма запроса данных из стейта является избыточной и зачастую удобнее пользоваться просто перечислением свойств в массиве.

Итак, мы реализовали стейт и разобрались как получить из него данные. Пойдем дальше и добавим в стор вычисляемое свойство и рассмотрим, как оно работает на примере счетчика.
Вычисляемые свойства реализуются при помощи геттеров. Геттеры описываются при помощи свойства getters, значением которого является объект со списком методов, возвращающих какое либо значение.
Посмотрим, как это выглядит на примере.

	getters: {
		userCount(state) {
			return state.users.length;
		}
	}

Как видите, снова ни чего сложого )

До сих пор мы работали в режиме read-only, то есть только отображали данные. Настало время перейти к их модификации. Модифицировать будем список пользователей.
Начнем с добавления новых данных в список. Давайте реализуем эту функциональность. Модификация данных в сторе осуществляется при помощи мутаций.
Поэтому давайте опишем мутацию addUser. На первом этапе пусть наша мутация выводит что нибудь в консоль, просто, чтобы проследить, что она вызывается.

	mutations: {
		addUser(state) {
			console.log('addUser *')
		}
	}


В компоненте nav-bar.vue у нас уже добавлен обработчик на текстовое поле и на кнопку, которые вызывают метод addUser. Опишим этот метод в компоненте. 

	methods: {
		addUser() {
			this.$store.commit('addUser')
		}
	}

Вызов мутации осуществляется при помощи метода commit, которому в качестве первого аргумента передаем имя мутации. В нашем случае это 'addUser'.
Заметте, что метод commit принадлежит стору, а значит его можно вызывать из любого компонента или даже из консоли браузера. Иногда при отладке это может быть особенно полезно.

Теперь давайте доработаем мутацию и метод внутри компонента. Первым аргументом мутация всегд апринимает стейт, а вторым, если это нужно, данные, с котороым мутация будет работать.

	mutations: {
		addUser(state, name) {
			const id = Math.floor(Math.random() * new Date().getTime()).toString(16);
			state.users = [{id, name}, ...state.users];
		},
	}

	- - -

	methods: {
		addUser(e) {
			const el = this.$refs.userName;

			if (el.value.trim() !== '') {

				this.$store.commit('addUser', el.value)

				el.value = '';
				el.focus();
			}
		}
	}


