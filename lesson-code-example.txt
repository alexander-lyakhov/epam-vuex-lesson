
Сейчас я предлагаю рассмотреть, как теория работает в реальных условиях.
Специально для этого урока я приготовил небольшой пример, который поможет нам проследить все оснавные принципы работы со стором.
Мы рассмотрим такие вопросы, как доступ к данным в стейте, работа с геттерами, мутации и экшины. А также рассмотрим разделение стора на отдельные модули.
Применение модулей является очень удобной практикой в больших приложениях.

Для начала я покажу приложение в работе, а затем последовательно, шаг за шагом мы реализуем лигику этого приложения при помощи Vuex.

***
Переключаемся на приложение
***

Вначале пара слов о приложении.
Основное назначение этого примера - управление списком пользователей. Данные о пользователях как раз хранятся в сторе.

Что у нас тут есть? В двух словах расскажу об элементах управления и опишу с какими функциями Vuex'а эти элементы связаны.

- Немного информации об аккаунте. Эта информация тоже хранится в сторе и мы будем читать ее напрямую из стейта.

- Счетчик пользователей. Его мы реализуем при помощи геттеров внутри стора. Напомню, что компоненты Vue тоже могут использовать внутри себя геттеры
  и в этом примере мы также будем ими польваться.

- Поле для ввода имени нового пользователя. С его помощью будем добавлять новые данные в стор.

- После добавления, мы имеем возможность удалить записи из стора. Обе эти операции (добавление и удаление) изменяют данные в стейте, и для этой цели служат мутации.

- А таже у нас есть возможность подгружать данные с удаленного сервера.
  Это асинхронная операция и специально для таких таких операций (для работы с асинхронными действиями) предназначены экшены.
  Напомню, что в отличии от экшинов МУТАЦИИ являются операциями синхронными.


Ссылку на этот пример я оставлю в конце лекции.



*  *  *

Теперь после того, как мы определились, какое поведение мы ожидаем от нашего приложения, я предлагаю перейти к его реализации.
У меня есть копия этого приложения без стора. Соответственно у нас нет ни каких данных и логики по работе с этими данными.

Мы можем видеть вместо имени в аккаунте строку Name, которая вписана туда хардкодом. Вместо аватарки мы вообще ни чего не видим.
Значение счетка тоже установлено в 0. Сейчас мы будем это исправлять.

Прежде всего давайте создадим и зарегистрируем наше хранилище. Для этого в папке src создадим новую папку store и в ней файл с однойменным названием.
Теперь осталось создать сам стор )
В качестве аргумента конструктор стора принимает объект с конфигурацией. Сейчас этот объект пустой. Конфигурация представляет собой набор вложенных подобъектов,
которые внутри себя содержат данные, а так же методы взыимодействия с с этими данными. Не пугайтесь, сейчас все увидите сами )
Главной и единственной обязательной частью стора является state, в котором собственно данне и хранятся. Те из вас, кто работал с redux'ом смогут заметить сходство в терминалогии.
Суть и концепция у них тоже одна.
Итак давайте опишим стейт и общую структуру стора.

Наш стор готов. Но пока он существует сам по себе, приложение о ним ни чего не знает. Следующее, что нам нужно сделать - это импортировать наш стор в main.js
Затем нам нужно передать импортированный стор в конйигурацию корневого компонента.
Это нужно для того, чтобы любой дочерний компонент внутри себя имел доступ к стору без необходимости импортировать его.
Ну а поскольку любой компонент в приложении является дочерним по отношению к корневому, то выходит, что все компоненты автоматически получают доступ к стору.

Итак стор создан и подключен. Можно переходить к работе с данными из стора. Давайте попробуем вывести поле accountName в хедер. Будем желать это в файле nav-bar.vue
Для начала рассмотрим, какие есть способы обратиться к данным в сторе из компонента. Давайте создадим хук created в котором выведем в консоль поле accountName из стора.

		created() {
			console.log(this.$store.state.accountName)
		}

Как вы можете видеть в консоль вывелось значение поля, взятого из стейта. Теоретически мы можем указать в шаблоне прямо это выражение для вывода имени.
Это работает, но согласитесь это не очень красивая запись. Обычно так не делают, потому что есть возможность сделать это красивее и понятнее.
Мы можем создать вычисляемое поле, которое так и назовем accountName, и оно будет нам возвращать значение этого выражения.

		computed: {
			accountName() {
				return this.$store.state.accountName;
			}
		}

Теперь нам достаточно указать в шаблоне только имя вычисляемого свойства.
То же самое проделаем для аватара.

			accountAvatar() {
				return this.$store.state.accountAvatar;
			}

Как видите, такой способ более изящный и не перегружает шаблон.
Существует еще один способ обратиться к стору - через маппинг стейта и методов. Он немного напоминает способ, который применяется в связке рекат-редакс.
Давайте посмотрим, как это происходит.

Прежде всего нам нужно импортировать метод mapState из Vuex.
Затем в секции computed мы вызываем этот метод, которому в качестве параметра передаем массив со списком свойств, котороые мы хотим получить из стейта.

		computed: {
			...mapState(['accountName', 'accountAvatar']),
		}

Метод mapState возвращает объект, который мы разворачиваем при помощи spread-оператора и подмешиваем его к объкту computed.
Внутри computed по прежнему могут находиться вычисляемые свойства, которые нам необходимы.
Такой способ получения данных из стора еще проще, чем способы рассмотренные ранее.
Кроме того он удобней, когда нам нужно запросить большое количиство полей из стейта. В этом случае нам не придется для каждого свойства определять геттеры.
Стоит отметить, что метод mapState может принимать не только массив, но и объект с парами ключ-значение. Давайте я покажу такоу форму записи.

		...mapState({
			accountName: 'accountName',
			accountAvatar: 'accountAvatar'
		})

Такой формат можно применять, если мы хотим изменить название свойства, использовать это свойство в компоненте под другим именем.
Тогда мы просто указываем имя ключа, которое нам нужно, а имя свойства в стейте указываем таким, каким оно там определено.
Однако такой формат зачастую является избыточной и обычно удобнее пользоваться просто перечислением свойств в массиве.
Нужно сказать, что метод mapState удобен в безмодульной реализации стора. В модульной же, появляются нюансы, которые я сейчас описывать не буду, чтобы не перегружать вас информацией.
Лишь скажу, что в модульной реализации удобнее работать через геттеры.

Теперь давйте по той же схеме реализуем вывод списка. Я временно добавлю в массив с пользователями несколько пустых объектов, просто чтобы чем то заполнить массив.
Откроем файл user-list.vue и добавим туда необходимый код.

		computed: {
			...mapState(['users'])
		}

Ну вот и все ) Хочу обратить ваше внимание на то, что когда нам необходимо сделать маппинг свойств, не важно из сиейта или вычисляемых свойств, то делаем мы это в секции computed.

Итак, мы реализовали стейт и разобрались как получить из него данные. Пойдем дальше и добавим в стор вычисляемое свойство и рассмотрим, как оно работает на примере счетчика.
Вычисляемые свойства реализуются при помощи геттеров. Геттеры описываются при помощи свойства getters, значением которого является объект со списком методов, возвращающих какое либо значение.
Посмотрим, как это выглядит на примере.

	getters: {
		userCount(state) {
			return state.users.length;
		}
	}

Как видите, снова ни чего сложого ) Давайте теперь уберем моковые данные ез массива полтзователей, они нам больше не нужны.
Обратите внимание на то, что мы работали с 3мя разными компонентами, которые использовали данные из одного стора.
Этот факт лишний раз подчеркивает концепцию Vuex-а как глобального хранилища данных - данные хранятся централизованно и могут использоваться в разных частях приложения.

До сих пор мы работали в режиме read-only, то есть только отображали данные. Настало время перейти к их модификации. Модифицировать будем список пользователей.
Начнем с добавления новых данных в список. Давайте реализуем эту функциональность. Модификация данных в сторе осуществляется при помощи мутаций.
Поэтому давайте опишем мутацию ADD_USER. На первом этапе пусть наша мутация выводит что нибудь в консоль, просто, чтобы проследить, что она вызывается.

	mutations: {
		ADD_USER(state) {
			console.log('ADD_USER *')
		}
	}

Есть смысл давать имена мутациям в апперкейсе, хотя это совсем не обязательно. Позже вы увидите почему в этом есть смысл.

В компоненте nav-bar.vue у нас уже добавлен обработчик на текстовое поле и на кнопку, которые вызывают метод addUser. Опишим этот метод в компоненте.

	methods: {
		addUser() {
			this.$store.commit('ADD_USER')
		}
	}

Вызов мутации осуществляется при помощи метода commit, которому в качестве первого аргумента передаем имя мутации. В нашем случае это 'ADD_USER'.
Заметте, что метод commit принадлежит стору, а значит его можно вызывать из любого компонента или даже из консоли браузера. Иногда при отладке это может быть особенно полезно.

Теперь давайте доработаем мутацию и метод внутри компонента. Первым аргументом мутация всегда принимает стейт, а вторым, если это нужно, данные, с которыми мутация будет работать.

	mutations: {
		ADD_USER(state, name) {
			const id = Math.floor(Math.random() * new Date().getTime()).toString(16);
			state.users = [{id, name}, ...state.users];
		},
	}

	- - -

	methods: {
		addUser(e) {
			const el = this.$refs.userName;

			if (el.value.trim() !== '') {

				this.$store.commit('ADD_USER', el.value)

				el.value = '';
				el.focus();
			}
		}
	}

Мутации, так же, как и стейт и геттеры, можно мапить в компонент. Для этого нужно импортировать метод mapMutations и подмешать результат его вызова в секцию methods.
Теперь вместо вызова метода commit нам достаточно просто вызвать метод this.ADD_USER с нужными нам параметрами.

Отлично! У нас уже есть мутация по добавлению пользователей в список. Теперь давайте создадим мутацию для удаления и вызовим ее из файла user-list.js

		REMOVE_USER(state, id) {
			this.state.users = this.state.users.filter(item => item.id !== id);
		}

	- - -

		methods: {
			removeUser(id) {
				this.$store.commit('REMOVE_USER', id);
			}
		}

Почти все готово. Из функциональности нам осталось добавить только подгрузку данных с сервера, которую мы реализуем при помощи экшена. Созданим экшн LOAD_USERS

	actions: {
		LOAD_USERS(context) {
			console.log(context)
		}
	}

В качестве первого аргумента экшн принимает объект context. Внутри себя он содержит ссылки на методы и объеты стора. Среди них нас интересует ссылка на метод commit,
которую мы можем получить сразу путем деструкторизации входящего аргумента. И давайте пропишем запрос к серверу и обработку его ответа.

	actions: {
		LOAD_USERS({commit}) {
			return fetch('https://jsonplaceholder.typicode.com/users')
				.then(res => res.json())
				.then(users => commit('POPULATE_USERS', users))
		}
	}

В компоненте app.js реализуем метод loadUsers() из которого будем вызывать экшн.

		methods: {
			loadUsers() {
				this.$store.dispatch('LOAD_USERS')
			}
		}

Снова замечу, что вызов мутаций и экшенов просиходит из разных комонентов, а их реализация находится в централизованном хранилище - в сторе.

В отличие от мутаций экшены вызываются методом dispatch. В отсально м синтакцис совпадает: первым аогументом мы указываем имя экшна, вторым - данные, которые нам нужно передать в экшн.
И как вы уже наверно догадываетесь экшыны тоже можно мапить в компонент. Делается это точно так же, как и с мутациями, только вмето мутаций мы импортируем и вызываем mapActions.
Делать я этого сейчас не буду, однако обращу ваше внимание на следующую деталь. Когда мы мапим стейт и геттеры, мы делаем это в разделе computed, когда мы мапим мутации и экшены,
тогда в разделе methods (ну потому что технически это методы ))

Вот мы и разобрали устройство и работу стора, который реалитзуется посредством библиотеки Vuex. Однако для полноты картины стоит еще рассказать о модулях.
В начале лекции я упоминал о них и том, что в больших проектах имеет смысл разделять стор на составляющие части. Наше приложение, хоть и небольшое,
но хорошо подходит для демонстрации этой возможности. Мы можем разжелить наши данные на 2 смысловые составляющие.

1. Информация об аккаунте
2. Данные о пользователях (в нашем случае это просто список пользователей)

Стало быть мы можем созать 2 модуля с такими данными. Что же такое модуль, как он выглядит? Если кратко, то это объект, который описывает стейт и методы работы с ним (геттеры, мутации, экшены).
В нашем примере это тот объект, который мы передали в конструктор стора в качестве аргумента. Можно сказать, что наш пример состоит из одного модуля. Правда в случае, когда модулей несколько,
мы явно указывем это. Итак давайте создадим модули. В папке store создадим папку modules, в которой создадим 2 фалйла, которые будут описывать модули. Это файл account.js и usrs.js
Все, что нам нужно - это экспортировать из каждого такого фала объет, который описывает наши данные. Поясню на примере. Перенем данные, относящиеся к аккаунту в файл account.js

import avatar from '@/assets/avatar.jpg'

export default {
	namespaced: true,

	state: {
		accountName: 'Alexander',
		accountAvatar: avatar,
	}
}

Собсьвенно все. Для аккаунта у нас нет ни геттеров, ни мутаций, ни экшенов.
Теперь тоже самое проделаем для пользователей в файле users.js Тут кода немного больше

export default {
    namespaced: true,

	state: {
		users: []
	},

	getters: {
		userCount(state) {
			return state.users.length;
		}
	},

	mutations: {

		ADD_USER(state, name) {
			const id = Math.floor(Math.random() * new Date().getTime()).toString(16);
			state.users = [{id, name}, ...state.users];
		},

		POPULATE_USERS(state, data) {
			state.users = [...data, ...state.users];
		},

		REMOVE_USER(state, id) {
			console.log(this.state)
			state.users = state.users.filter(item => item.id !== id);
		}
	},

	actions: {
		LOAD_USERS({commit}) {
			return fetch('https://jsonplaceholder.typicode.com/users')
				.then(res => res.json())
				.then(users => commit('POPULATE_USERS', users))
		}
	}
}

К обоим модулям я добавил атрибут 'namespaced: true'. Он указывает на то, что каждый модуль будет помещен в собственный namespace, и чтобы обратиться
к его стейту, мутациям или экшенам нужно указать namespace. Такой подход лучше формализует работу со стором, но не является обязательным. По умолчанию
параметр namespace в мудулях установлен в значение false.

Тепеь нам осталось собрать вместе эти модули и подключить их к стору. Чтобы не портить файл store.js которому мы посвятили почти всю лекцию,
давайте рядом создадим файл index.js и поправим поключение стора в main.js

	import Vue from "vue";
	import Vuex from "vuex";

	import account from './modules/account.js';
	import users from './modules/users.js';

	Vue.use(Vuex);

	export default new Vuex.Store({
		modules: {
			account,
			users
		}
	});

Нам осталось поправить обращения к стору из компонентов, записав их с учетом namespace'ов молулей
